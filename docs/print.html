<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>靺鞨笔记</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="leetcode/leetcode.html"><strong aria-hidden="true">1.</strong> LeetCode</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="leetcode/linkedlist.html"><strong aria-hidden="true">1.1.</strong> LinkedList</a></li><li class="chapter-item expanded "><a href="leetcode/binary_search.html"><strong aria-hidden="true">1.2.</strong> Binary Search</a></li><li class="chapter-item expanded "><a href="leetcode/dijkstra.html"><strong aria-hidden="true">1.3.</strong> Dijkstra</a></li><li class="chapter-item expanded "><a href="leetcode/math.html"><strong aria-hidden="true">1.4.</strong> Math</a></li><li class="chapter-item expanded "><a href="leetcode/segment_tree.html"><strong aria-hidden="true">1.5.</strong> Segment Tree</a></li></ol></li><li class="chapter-item expanded "><a href="system_design/system_design.html"><strong aria-hidden="true">2.</strong> System Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="system_design/examples/netflix_zuul.html"><strong aria-hidden="true">2.1.</strong> Netflix Zuul</a></li></ol></li><li class="chapter-item expanded "><a href="blog/blog.html"><strong aria-hidden="true">3.</strong> Blog</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="blog/random-thoughts-on-tech/000-2022-New-Years-Resolution.html"><strong aria-hidden="true">3.1.</strong> 2022 New Year Resolution</a></li><li class="chapter-item expanded "><a href="blog/random-thoughts-on-tech/001-互联网时代的终结.html"><strong aria-hidden="true">3.2.</strong> 互联网时代的终结 </a></li><li class="chapter-item expanded "><a href="blog/random-thoughts-on-tech/002-把复杂留给自己，把简单留给客户.html"><strong aria-hidden="true">3.3.</strong> 002</a></li><li class="chapter-item expanded "><a href="blog/random-thoughts-on-tech/003-Serverless 新的云服务边疆.html"><strong aria-hidden="true">3.4.</strong> 003</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">靺鞨笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="leetcode"><a class="header" href="#leetcode">leetcode</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linkedlist"><a class="header" href="#linkedlist">LinkedList</a></h1>
<p>Let's first take a look at how LeetCode define the LinkedList in rust</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
    pub val: i32,
    pub next: Option&lt;Box&lt;ListNode&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>As LeetCode is using <code>Box</code> as the pointer to point to the next node. It does not allow multiple reference to the same node and does not allow interior mutability. Hence, to make our life easier, we would like to change the <code>ListNode</code> definition to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq, Clone, Debug)]
pub struct MutListNode {
    pub val: i32,
    pub next: Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>With <code>Rc&lt;T&gt;</code>, we allow multiple ownership to the same <code>MutListNode</code></li>
<li>With <code>RefCell&lt;T&gt;</code>, we allow interior mutability for the heap allocated <code>MutListNode</code></li>
</ul>
<p>To convert between the LeetCode official <code>ListNode</code> and the mutable multi-referencing <code>MutListNode</code> we would need the following conversion utility functions</p>
<p>From <code>Option&lt;Box&lt;ListNode&gt;&gt;</code> to <code>Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_mut_list_node(node: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt; {
    match node {
        None =&gt; None,
        Some(node) =&gt; Some(Rc::new(RefCell::new(MutListNode {
            val: node.val,
            next: to_mut_list_node(node.next),
        }))),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>From <code>Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;</code> to <code>Option&lt;Box&lt;ListNode&gt;&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn to_list_node(node: Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
    match node {
        None =&gt; None,
        Some(node) =&gt; Some(Box::new(ListNode {
            val: node.borrow().val,
            next: to_list_node(node.borrow().next.clone()),
        })),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
    pub val: i32,
    pub next: Option&lt;Box&lt;ListNode&gt;&gt;,
}

impl ListNode {
    #[inline]
    fn new(val: i32) -&gt; Self {
        ListNode { next: None, val }
    }
}

#[derive(PartialEq, Eq, Clone, Debug)]
pub struct MutListNode {
    pub val: i32,
    pub next: Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;,
}

impl MutListNode {
    #[inline]
    fn new(val: i32) -&gt; Self {
        MutListNode { next: None, val }
    }
}

fn to_mut_list_node(node: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt; {
    match node {
        None =&gt; None,
        Some(node) =&gt; Some(Rc::new(RefCell::new(MutListNode {
            val: node.val,
            next: to_mut_list_node(node.next),
        }))),
    }
}

fn to_list_node(node: Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
    match node {
        None =&gt; None,
        Some(node) =&gt; Some(Box::new(ListNode {
            val: node.borrow().val,
            next: to_list_node(node.borrow().next.clone()),
        })),
    }
}

fn vec_to_linked_list(vec: Vec&lt;i32&gt;) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
    let mut root = ListNode::new(0);
    let mut curr = &amp;mut root;
    for n in vec {
        curr.next = Some(Box::new(ListNode::new(n)));
        curr = curr.next.as_mut().unwrap();
    }

    root.next
}

fn linked_list_to_vec(node: Option&lt;Box&lt;ListNode&gt;&gt;) -&gt; Vec&lt;i32&gt; {
    let mut vec = vec![];

    let mut curr = node;
    while curr != None {
        vec.push(curr.as_ref().unwrap().val);
        curr = curr.unwrap().next;
    }

    vec
}

fn vec_to_mut_linked_list(vec: Vec&lt;i32&gt;) -&gt; Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt; {
    let root = Rc::new(RefCell::new(MutListNode::new(0)));
    let mut curr = root.clone();
    for n in vec {
        curr.borrow_mut().next = Some(Rc::new(RefCell::new(MutListNode::new(n))));
        let next = curr.borrow().next.clone().unwrap();
        curr = next;
    }

    let node = root.borrow().next.clone();
    node
}

fn mut_linked_list_to_vec(node: Option&lt;Rc&lt;RefCell&lt;MutListNode&gt;&gt;&gt;) -&gt; Vec&lt;i32&gt; {
    let mut res = vec![];

    let mut curr = node;
    while let Some(curr_node) = curr {
        res.push(curr_node.borrow().val);
        curr = curr_node.borrow().next.clone();
    }

    res
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h1>
<h2 id="template"><a class="header" href="#template">Template</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn check(mid: i32) -&gt; bool {
    todo!()
}

fn binary_search() -&gt; i32 {
    let mut left = 0;
    let mut right = i32::MAX;

    while left &lt; right {
        let mid = left + (right - left) / 2;
        if check(mid) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }

    left
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="key-approaches"><a class="header" href="#key-approaches">Key Approaches</a></h2>
<p><em>Credit to @Lee215</em></p>
<ol>
<li>
<p>use <code>left &lt; right</code> or <code>left &lt;= right</code></p>
<p>to make the binary search process easier, we do not handle the <code>left == right</code> case in the loop. Instead, we will try to make the least <code>left</code> index to point to the correct answer that we are looking for.</p>
</li>
<li>
<p>use <code>mid = left + (right - left) / 2</code> or <code>mid = left + (right - left + 1) / 2</code></p>
<ul>
<li>use <code>mid = left + (right - left) / 2</code> to find the index of the first valid element</li>
<li>use <code>mid = left + (right - left + 1) / 2</code> to find the index of the last valid element</li>
</ul>
</li>
</ol>
<h2 id="search-for-the-first-index-of-the-valid-value"><a class="header" href="#search-for-the-first-index-of-the-valid-value">Search for the first index of the valid value</a></h2>
<pre><code>  0   1   2   3   4   5   6   7   8   9
 --- --- --- --- --- --- --- --- --- ---
| 0 | 0 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |
 --- --- --- --- --- --- --- --- --- ---
                  ^
                  |
                target

                  ^   ^   ^   ^   ^   ^
                  |   |   |   |   |   |
                          valid
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">   let list = vec![0, 0, 1, 1, 2, 2, 2, 3, 3, 3];
</span><span class="boring">   let k = 2;
</span><span class="boring">   let res = binary_search_first_valid(list, k);
</span><span class="boring">   println!(&quot;Result: {:?}&quot;, res);
</span><span class="boring">}
</span><span class="boring">
</span>fn binary_search_first_valid(list: Vec&lt;i32&gt;, target: i32) -&gt; usize {
    fn check(list: &amp;Vec&lt;i32&gt;, mid: usize, target: i32) -&gt; bool {
        list[mid] &gt;= target
    }

    let mut left = 0;
    let mut right = list.len();

    while left &lt; right {
        let mid = left + (right - left) / 2;
        if check(&amp;list, mid, target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    left
}
</code></pre></pre>
<h2 id="search-for-the-last-index-of-the-valid-value"><a class="header" href="#search-for-the-last-index-of-the-valid-value">Search for the last index of the valid value</a></h2>
<pre><code>  0   1   2   3   4   5   6   7   8   9
 --- --- --- --- --- --- --- --- --- ---
| 0 | 0 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 |
 --- --- --- --- --- --- --- --- --- ---
                          ^
                          |
                        target
  ^   ^   ^   ^   ^   ^   ^
  |   |   |   |   |   |   |
            valid
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let list = vec![0, 0, 1, 1, 2, 2, 2, 3, 3 ,3];
</span><span class="boring">    let k = 2;
</span><span class="boring">    let res = binary_search_last_valid(list, k);
</span><span class="boring">    println!(&quot;Result: {:?}&quot;, res);
</span><span class="boring">}
</span><span class="boring">
</span>fn binary_search_last_valid(list: Vec&lt;i32&gt;, target: i32) -&gt; usize {
    fn check(list: &amp;Vec&lt;i32&gt;, mid: usize, target: i32) -&gt; bool {
        list[mid] &lt;= target
    }

    let mut left = 0;
    let mut right = list.len();

    while left &lt; right {
        let mid = left + (right - left + 1) / 2;
        if check(&amp;list, mid, target) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }

    left
}
</code></pre></pre>
<h2 id="search-for-the-exact-index-of-a-valid-element"><a class="header" href="#search-for-the-exact-index-of-a-valid-element">Search for the exact index of a valid element</a></h2>
<pre><code>  0   1   2   3   4   5   6   7   8   9
 --- --- --- --- --- --- --- --- --- ---
| 0 | 0 | 1 | 1 | 1 | 1 | 2 | 3 | 3 | 3 |
 --- --- --- --- --- --- --- --- --- ---
                          ^
                          |
                        target
</code></pre>
<p>The first approach is to use the rust built-in binary search method of a <code>Vec</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = vec![0, 0, 1, 1, 1, 1, 2, 3, 3 ,3];
let target = 2;
let res = list.binary_search(&amp;target);
println!(&quot;Result: {:?}&quot;, res); // Ok(6)
<span class="boring">}
</span></code></pre></pre>
<p>Another benefit is the built in binary search method will also yield the location where the given value should be inserted to keep the <code>Vec</code> in the sorted order.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = vec![0, 0, 1, 1, 1, 1, 3, 3, 3 ,3];
let target = 2;
let res = list.binary_search(&amp;target);
println!(&quot;Result: {:?}&quot;, res); // Err(6)
<span class="boring">}
</span></code></pre></pre>
<p>Let's see how can we adapt the &quot;Search for the first index of the valid value&quot; to do the same as the above built-in binary search function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">   let list = vec![0, 0, 1, 1, 2, 3, 3, 3, 3, 3];
</span><span class="boring">   let k = 2;
</span><span class="boring">   let res = binary_search(list, k);
</span><span class="boring">   println!(&quot;Search for 2 in the list [0, 0, 1, 1, 2, 3, 3, 3, 3, 3]&quot;);
</span><span class="boring">   println!(&quot;Result: {:?}&quot;, res);
</span><span class="boring">
</span><span class="boring">   let list = vec![0, 0, 1, 1, 2, 3, 3, 3, 3, 3];
</span><span class="boring">   let k = 4;
</span><span class="boring">   let res = binary_search(list, k);
</span><span class="boring">   println!(&quot;Search for 4 in the list [0, 0, 1, 1, 2, 3, 3, 3, 3, 3]&quot;);
</span><span class="boring">   println!(&quot;Result: {:?}&quot;, res);
</span><span class="boring">}
</span><span class="boring">
</span>fn binary_search(list: Vec&lt;i32&gt;, target: i32) -&gt; Result&lt;usize, usize&gt; {
    fn check(list: &amp;Vec&lt;i32&gt;, mid: usize, target: i32) -&gt; bool {
        list[mid] &gt;= target
    }

    let mut left = 0;
    let mut right = list.len();

    while left &lt; right {
        let mid = left + (right - left) / 2;
        if check(&amp;list, mid, target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    if left &lt; list.len() {
        Ok(left)
    } else {
        Err(left)
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dijkstra-f64"><a class="header" href="#dijkstra-f64">Dijkstra f64</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::cmp::Ordering;
use std::collections::BinaryHeap;

#[derive(PartialEq, PartialOrd)]
struct Node {
    node: usize,
    prob: f64,
}

impl Eq for Node {}

impl Ord for Node {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        // Max-heap
        self.prob
            .partial_cmp(&amp;other.prob)
            .unwrap()
            .then_with(|| self.node.cmp(&amp;other.node))
    }
}

struct Solution {}

impl Solution {
    pub fn max_probability(
        n: i32,
        edges: Vec&lt;Vec&lt;i32&gt;&gt;,
        succ_prob: Vec&lt;f64&gt;,
        start: i32,
        end: i32,
    ) -&gt; f64 {
        let n = n as usize;
        let start = start as usize;
        let end = end as usize;
        let graph = Self::convert_edge_list_to_adjacency_list(edges, succ_prob, n);

        // Dijkstra
        // Edges: E
        // Nodes/Vertices: V
        //
        // Time Complexity: O(E + V log V )
        // Space Complexity: O(V)
        let mut cost = vec![0.0; n];
        cost[start] = 1.0;

        let mut pq: BinaryHeap&lt;Node&gt; = BinaryHeap::new();
        pq.push(Node {
            node: start,
            prob: 1.0,
        });

        while let Some(node) = pq.pop() {
            for (next, edge_prob) in &amp;graph[node.node] {
                let prob = *edge_prob * node.prob;
                if prob &gt; cost[*next] {
                    cost[*next] = prob;
                    pq.push(Node { node: *next, prob })
                }
            }
        }

        cost[end]
    }

    /// Edges: E
    /// Nodes/Vertices: V
    ///
    /// Time Complexity: O(E)
    /// Space Complexity: O(V + E)
    fn convert_edge_list_to_adjacency_list(
        edges: Vec&lt;Vec&lt;i32&gt;&gt;,
        succ_prob: Vec&lt;f64&gt;,
        n: usize,
    ) -&gt; Vec&lt;Vec&lt;(usize, f64)&gt;&gt; {
        let mut graph: Vec&lt;Vec&lt;(usize, f64)&gt;&gt; = vec![vec![]; n];
        for i in 0..edges.len() {
            let u = edges[i][0] as usize;
            let v = edges[i][1] as usize;
            let prob = succ_prob[i];
            graph[u].push((v, prob));
            graph[v].push((u, prob));
        }
        graph
    }
}

fn main() {
    let n = 3;
    let edges = [[0, 1], [1, 2], [0, 2]];
    let edges: Vec&lt;Vec&lt;i32&gt;&gt; = edges.into_iter().map(|e| e.to_vec()).collect();
    let succ_prob = [0.5, 0.5, 0.2];
    let succ_prob: Vec&lt;f64&gt; = succ_prob.into_iter().collect();
    let start = 0;
    let end = 2;
    let res = Solution::max_probability(n, edges, succ_prob, start, end);
    println!(&quot;{:?}&quot;, res);
}

</code></pre></pre>
<h2 id="dijkstra-i64"><a class="header" href="#dijkstra-i64">Dijkstra i64</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::{cmp::Ordering, collections::BinaryHeap};

#[derive(Eq, PartialEq)]
struct Node {
    index: usize,
    cost: i64,
}

impl Ord for Node {
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {
        // min-heap
        other
            .cost
            .cmp(&amp;self.cost)
            .then_with(|| self.index.cmp(&amp;other.index))
    }
}

impl PartialOrd for Node {
    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {
        Some(self.cmp(other))
    }
}

struct Solution {}

impl Solution {
    const MODULO: i64 = 10_0000_0007;

    /// Edges: E
    /// Nodes/Vertices: V
    ///
    /// Time Complexity: O(E)
    /// Space Complexity: O(V + E)
    fn convert_edge_list_to_adjacency_list(
        edges: Vec&lt;Vec&lt;i32&gt;&gt;,
        n: usize,
    ) -&gt; Vec&lt;Vec&lt;(usize, i64)&gt;&gt; {
        let mut graph: Vec&lt;Vec&lt;(usize, i64)&gt;&gt; = vec![vec![]; n];
        for edge in edges {
            let src = edge[0] as usize;
            let dst = edge[1] as usize;
            let cost = edge[2] as i64;
            graph[src].push((dst, cost));
            graph[dst].push((src, cost));
        }
        graph
    }

    pub fn count_paths(n: i32, roads: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {
        let n = n as usize;
        let graph: Vec&lt;Vec&lt;(usize, i64)&gt;&gt; = Self::convert_edge_list_to_adjacency_list(roads, n);
        let mut cost: Vec&lt;i64&gt; = vec![i64::MAX; n];
        let mut path_count: Vec&lt;i64&gt; = vec![0; n];

        // Dijkstra
        // Edges: E
        // Nodes/Vertices: V
        //
        // Time Complexity: O(E + V log V )
        // Space Complexity: O(V)
        let mut pq: BinaryHeap&lt;Node&gt; = BinaryHeap::new();
        path_count[0] = 1;
        cost[0] = 0;
        pq.push(Node { index: 0, cost: 0 });

        while let Some(node) = pq.pop() {
            for (next_index, next_cost) in &amp;graph[node.index] {
                if node.cost + *next_cost &gt; cost[*next_index] {
                    continue;
                } else if cost[*next_index] == node.cost + *next_cost {
                    path_count[*next_index] =
                        (path_count[*next_index] + path_count[node.index]) % Self::MODULO;
                } else {
                    cost[*next_index] = node.cost + *next_cost;
                    path_count[*next_index] = path_count[node.index];
                    pq.push(Node {
                        index: *next_index,
                        cost: node.cost + *next_cost,
                    });
                }
            }

            // println!(&quot;{:?} {:?} {:?}&quot;, node.index, node.cost, node.path);
            // println!(&quot;{:?}&quot;, cost);
            // println!(&quot;{:?}&quot;, path_count);
        }

        path_count[n - 1] as i32
    }
}

fn main() {
    let n = 7;
    let roads = [
        [0, 6, 7],
        [0, 1, 2],
        [1, 2, 3],
        [1, 3, 3],
        [6, 3, 3],
        [3, 5, 1],
        [6, 5, 1],
        [2, 5, 1],
        [0, 4, 5],
        [4, 6, 2],
    ];
    let roads = roads.into_iter().map(|r| r.to_vec()).collect();
    let res = Solution::count_paths(n, roads);
    println!(&quot;{:?}&quot;, res);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">Math</a></h1>
<h2 id="greatest-common-divisor"><a class="header" href="#greatest-common-divisor">Greatest Common Divisor</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;gcd of 10 and 5  is {}&quot;, greatest_common_divisor(10, 5));
</span><span class="boring">    println!(&quot;gcd of 11 and 22 is {}&quot;, greatest_common_divisor(11, 22));
</span><span class="boring">    println!(&quot;gcd of 44 and 63  is {}&quot;, greatest_common_divisor(44, 63));
</span><span class="boring">    println!(&quot;gcd of 44 and 64  is {}&quot;, greatest_common_divisor(44, 64));
</span><span class="boring">}
</span>
fn greatest_common_divisor(a: i32, b: i32) -&gt; i32 {
    if b != 0 {
        greatest_common_divisor(b, a % b)
    } else {
        a
    }
}
</code></pre></pre>
<h2 id="least-common-multiple"><a class="header" href="#least-common-multiple">Least Common Multiple</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;lcm of 10 and 5  is {}&quot;, least_common_multiple(10, 5));
</span><span class="boring">    println!(&quot;lcm of 11 and 22 is {}&quot;, least_common_multiple(11, 22));
</span><span class="boring">    println!(&quot;lcm of 44 and 63  is {}&quot;, least_common_multiple(44, 63));
</span><span class="boring">    println!(&quot;lcm of 44 and 64  is {}&quot;, least_common_multiple(44, 64));
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn greatest_common_divisor(a: i32, b: i32) -&gt; i32 {
</span><span class="boring">    if b != 0 {
</span><span class="boring">        greatest_common_divisor(b, a % b)
</span><span class="boring">    } else {
</span><span class="boring">        a
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn least_common_multiple(a: i32, b: i32) -&gt; i32 {
    a * b / greatest_common_divisor(a, b)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segment-tree-range-sum"><a class="header" href="#segment-tree-range-sum">Segment Tree Range Sum</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::{
    cmp::Ordering,
    collections::{BinaryHeap, HashMap, HashSet},
    fmt::{Binary, Debug},
};

fn main() {
    let vec = vec![1, 3, 5];

    let mut num_array = NumArray::new(vec);
    println!(&quot;{:?}&quot;, num_array.sum_range(0, 2));
    println!(&quot;{:?}&quot;, num_array.update(1, 2));
    println!(&quot;{:?}&quot;, num_array.sum_range(0, 2))
}

struct SegmentTreeNode&lt;'a, T&gt; {
    left_node: Option&lt;Box&lt;SegmentTreeNode&lt;'a, T&gt;&gt;&gt;,
    right_node: Option&lt;Box&lt;SegmentTreeNode&lt;'a, T&gt;&gt;&gt;,
    left_index: usize,
    right_index: usize,
    info: T,
    operation: &amp;'a dyn Fn(&amp;T, &amp;T) -&gt; T,
}

impl&lt;'a, T&gt; Debug for SegmentTreeNode&lt;'a, T&gt;
where
    T: Debug,
{
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.debug_struct(&quot;SegmentTreeNode&quot;)
            .field(&quot;left_node&quot;, &amp;self.left_node)
            .field(&quot;right_node&quot;, &amp;self.right_node)
            .field(&quot;left_index&quot;, &amp;self.left_index)
            .field(&quot;right_index&quot;, &amp;self.right_index)
            .field(&quot;info&quot;, &amp;self.info)
            .finish()
    }
}

impl&lt;'a, T&gt; SegmentTreeNode&lt;'a, T&gt;
where
    T: Copy + Debug,
{
    fn new_from_vec(vec: Vec&lt;T&gt;, operation: &amp;'a dyn Fn(&amp;T, &amp;T) -&gt; T) -&gt; Self {
        let left_index = 0;
        let right_index = vec.len() - 1;
        Self::new_from_slice(&amp;vec, left_index, right_index, operation)
    }

    fn new_from_slice(
        slice: &amp;[T],
        left_index: usize,
        right_index: usize,
        operation: &amp;'a dyn Fn(&amp;T, &amp;T) -&gt; T,
    ) -&gt; Self {
        if left_index == right_index {
            SegmentTreeNode {
                left_node: None,
                right_node: None,
                left_index,
                right_index,
                info: slice[0],
                operation,
            }
        } else {
            let mid_index = (left_index + right_index) / 2;
            let left_node = Self::new_from_slice(
                &amp;slice[0..=(mid_index - left_index)],
                left_index,
                mid_index,
                operation,
            );
            let right_node = Self::new_from_slice(
                &amp;slice[(mid_index - left_index + 1)..=(right_index - left_index)],
                mid_index + 1,
                right_index,
                operation,
            );

            let info = operation(&amp;left_node.info, &amp;right_node.info);

            SegmentTreeNode {
                left_node: Some(Box::new(left_node)),
                right_node: Some(Box::new(right_node)),
                left_index,
                right_index,
                info,
                operation,
            }
        }
    }

    fn update_index(&amp;mut self, index: usize, info: T) {
        if self.left_index == index &amp;&amp; self.right_index == index {
            self.info = info;
        }

        match (&amp;mut self.left_node, &amp;mut self.right_node) {
            (Some(left_node), Some(right_node)) =&gt; {
                if left_node.right_index &gt;= index {
                    left_node.update_index(index, info);
                } else {
                    right_node.update_index(index, info);
                }
                self.info = (self.operation)(&amp;left_node.info, &amp;right_node.info);
            }
            _ =&gt; (),
        }
    }

    fn range_operation(&amp;self, left_index: usize, right_index: usize) -&gt; T {
        if left_index &lt; self.left_index || right_index &gt; self.right_index {
            panic!(&quot;indexes out of range&quot;)
        }

        if left_index == self.left_index &amp;&amp; right_index == self.right_index {
            return self.info;
        }

        match (&amp;self.left_node, &amp;self.right_node) {
            (Some(left_node), Some(right_node)) =&gt; {
                if right_index &lt;= left_node.right_index {
                    left_node.range_operation(left_index, right_index)
                } else if left_index &gt;= right_node.left_index {
                    right_node.range_operation(left_index, right_index)
                } else {
                    (self.operation)(
                        &amp;left_node.range_operation(left_index, left_node.right_index),
                        &amp;right_node.range_operation(right_node.left_index, right_index),
                    )
                }
            }
            (Some(left_node), None) =&gt; left_node.range_operation(left_index, right_index),
            (None, Some(right_node)) =&gt; right_node.range_operation(left_index, right_index),
            (None, None) =&gt; unreachable!(),
        }
    }
}

struct NumArray&lt;'a&gt; {
    node: SegmentTreeNode&lt;'a, i32&gt;,
}

impl NumArray&lt;'_&gt; {
    fn new(nums: Vec&lt;i32&gt;) -&gt; Self {
        NumArray {
            node: SegmentTreeNode::new_from_vec(nums, &amp;|a: &amp;i32, b: &amp;i32| a + b),
        }
    }

    fn update(&amp;mut self, index: i32, val: i32) {
        self.node.update_index(index as usize, val)
    }

    fn sum_range(&amp;self, left: i32, right: i32) -&gt; i32 {
        self.node.range_operation(left as usize, right as usize)
    }
}

</code></pre></pre>
<h2 id="segment-tree-min-index"><a class="header" href="#segment-tree-min-index">Segment Tree Min Index</a></h2>
<pre><pre class="playground"><code class="language-rust">use std::{
    fmt::Debug,
    cmp::{Ordering, Reverse},
    collections::{BinaryHeap, HashMap, HashSet},
    fmt::Binary,
    hash::Hash,
};

fn main() {
    let  target = vec![1,2,3,2,1];
    let res = Solution::min_number_operations(target);
    println!(&quot;{:?}&quot;, res);
}

struct Solution;

impl Solution {
    pub fn min_number_operations(target: Vec&lt;i32&gt;) -&gt; i32 {
        let root = SegmentTreeNode::new_from_vec(&amp;target);
        Self::dfs(0, target.len() - 1, 0, &amp;root, &amp;target)
    }

    fn dfs(left_idx: usize, right_idx:usize, base: i32, root: &amp;SegmentTreeNode, target: &amp;Vec&lt;i32&gt;) -&gt; i32 {
        if right_idx &lt; left_idx {
            return 0;
        }
        if left_idx == right_idx {
            return target[left_idx] - base;
        }

        let (min_idx, min_val) = root.query_range_min(left_idx, right_idx);
        let mut res = min_val - base;
        if min_idx &gt; 0 { res += Self::dfs(left_idx, min_idx - 1, min_val, root, target); }
        res += Self::dfs(min_idx + 1, right_idx, min_val, root, target);

        res
    }
}


#[derive(Debug)]
struct SegmentTreeNode {
    left_node: Option&lt;Box&lt;SegmentTreeNode&gt;&gt;,
    right_node: Option&lt;Box&lt;SegmentTreeNode&gt;&gt;,
    left_index: usize,
    right_index: usize,
    min_idx: usize,
    min_val: i32,
}

impl SegmentTreeNode{
    fn new_from_vec(vec: &amp;Vec&lt;i32&gt;) -&gt; Self {
        let left_index = 0;
        let right_index = vec.len() - 1;
        Self::new_from_slice(&amp;vec, left_index, right_index)
    }

    fn new_from_slice(
        slice: &amp;[i32],
        left_index: usize,
        right_index: usize,
    ) -&gt; Self {
        if left_index == right_index {
            SegmentTreeNode {
                left_node: None,
                right_node: None,
                left_index,
                right_index,
                min_idx: left_index,
                min_val: slice[0],
            }
        } else {
            let mid_index = (left_index + right_index) / 2;
            let left_node = Self::new_from_slice(
                &amp;slice[0..=(mid_index - left_index)],
                left_index,
                mid_index,
            );
            let right_node = Self::new_from_slice(
                &amp;slice[(mid_index - left_index + 1)..=(right_index - left_index)],
                mid_index + 1,
                right_index,
            );

            let (min_idx, min_val) = if left_node.min_val &lt; right_node.min_val {
                (left_node.min_idx, left_node.min_val)
            } else {
                (right_node.min_idx, right_node.min_val)
            };

            SegmentTreeNode {
                left_node: Some(Box::new(left_node)),
                right_node: Some(Box::new(right_node)),
                left_index,
                right_index,
                min_idx,
                min_val,
            }
        }
    }

    fn query_range_min(&amp;self, left_index: usize, right_index: usize) -&gt; (usize, i32) {
        if right_index &lt; self.left_index || left_index &gt; self.right_index {
            (usize::MAX, i32::MAX)
        } else if left_index &lt;= self.left_index &amp;&amp; right_index &gt;= self.right_index {
            (self.min_idx, self.min_val)
        } else {
            let (left_min_idx, left_min_val) = self.left_node.as_ref().unwrap().query_range_min(left_index, right_index);
            let (right_min_idx, right_min_val) = self.right_node.as_ref().unwrap().query_range_min(left_index, right_index);
            if left_min_val &lt; right_min_val {
                (left_min_idx, left_min_val)
            } else {
                (right_min_idx, right_min_val)
            }
        }
    }
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-design"><a class="header" href="#system-design">System Design</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>After working in the software industry for over two years, I have learned a lot about what is hiring manager and interviewer looking for when hiring a new software development engineer. Nevertheless, to become an senior/staff engineer, there is still a long way to go. Since I departed from my first job at AWS, I have been trying to learn from lectures, books, and keynote presentations regarding the knowledge and skills that I need to tackle a system design interview. Here, is where I keep all my notes. It is not a guide, it is not a book, it is not even well-organized at all. However, it is where I keep the knowledge that I have learned so far.</p>
<h2 id="system-design-interview"><a class="header" href="#system-design-interview">System Design Interview</a></h2>
<h3 id="what-is-a-system-design-interview"><a class="header" href="#what-is-a-system-design-interview">What is a system design interview?</a></h3>
<ul>
<li>simulate in-team design process</li>
<li>solve an ambiguous problem</li>
<li>work with teammates/co-workers</li>
<li>two co-workers working together</li>
</ul>
<h3 id="what-are-the-desireable-traits"><a class="header" href="#what-are-the-desireable-traits">What are the desireable traits</a></h3>
<ul>
<li>ability to collaborate with teammates</li>
<li>work under pressure</li>
<li>work with ambiguous problem</li>
<li>constructive problem solving skills</li>
</ul>
<h3 id="what-are-the-undesirable-traits"><a class="header" href="#what-are-the-undesirable-traits">What are the undesirable traits</a></h3>
<ul>
<li>over-engineering solution</li>
<li>stubbornness</li>
<li>do not answer without thinking, or without understanding the question's scope, requirements, backgrounds, etc.</li>
</ul>
<h3 id="does-and-donts"><a class="header" href="#does-and-donts">Does and Don'ts</a></h3>
<p><strong>Dos</strong></p>
<ul>
<li>ask for clarification, do not make assumptions without verify with the interviewer</li>
<li>thinking aloud - communicate</li>
<li>make multiple design proposals</li>
<li>design the most critical parts first</li>
<li>ask for hints when stuck</li>
</ul>
<p><strong>Don'ts</strong></p>
<ul>
<li>do not go into detailed design in the early stage</li>
<li>do not thinking alone</li>
</ul>
<h3 id="the-approach"><a class="header" href="#the-approach">The approach</a></h3>
<p><strong>Approaches - four stages</strong></p>
<ol>
<li>Comprehend the requirement</li>
<li>Propose high-level designs</li>
<li>Detailed designs</li>
<li>Discussions</li>
</ol>
<p><strong>Stage 1: Comprehend the requirement</strong></p>
<ul>
<li>what does the customer/end-user wants?
<ul>
<li>what product feature is the customer looking for?</li>
<li>what problem is the customer trying to solve?</li>
</ul>
</li>
<li>what is the scale of the system?
<ul>
<li>how many users?</li>
<li>what is the avg/p100 qps</li>
<li>when does the customer need to scale 10x/100x</li>
</ul>
</li>
<li>understand the technology the team is using
<ul>
<li>AWS? GCP? Azure?</li>
<li>Java? Rust? Python?</li>
<li>GraphQL? gRPC? REST?</li>
</ul>
</li>
</ul>
<p><strong>Stage 2: Propose high-level designs</strong></p>
<ul>
<li>propose design for different scales
<ul>
<li>get the interviewers involved</li>
</ul>
</li>
<li>make some estimation on the traffic/scale
<ul>
<li>dive deep only if the interviewer is asking for deeper analysis</li>
</ul>
</li>
<li>design the api schema / database schema if it is suited to the question</li>
</ul>
<p><strong>Stage 3: Detailed design</strong></p>
<p><strong>Stage 4: Discussions</strong></p>
<ul>
<li>limitation, bottlenecks, disaster recovery, dev-ops, etc.</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Alex Xu - <em>System Design Interview - An Insider's Guide</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netflix-zuul-push"><a class="header" href="#netflix-zuul-push">Netflix Zuul Push</a></h1>
<h2 id="zuul-push-architecture"><a class="header" href="#zuul-push-architecture">Zuul Push Architecture</a></h2>
<p>Zuul Push is the push engine at Netflix</p>
<p><img src="system_design/examples/./images/netflix_zuul_000.png" alt="Zuul architecture" /></p>
<h3 id="workflow"><a class="header" href="#workflow">Workflow</a></h3>
<ol>
<li><strong>Client</strong> establishes an persistent websocket/SSE connection to the <strong>Zuul Push Service</strong>. The <strong>Client</strong> will keep the connection alive until the session is terminated.</li>
<li><strong>Zuul Push Service</strong> register the user and connection information to the <strong>Push Registry</strong> database.</li>
<li><strong>Service</strong> that need to send a push message (source of push message) use the <strong>Push Library</strong> (SDK) to send the message to the <strong>Push Message Queue</strong>.</li>
<li><strong>Message Processor</strong>
<ol>
<li>pulls/retrieves an message from the <strong>Push Message Queue</strong></li>
<li>lookups the <strong>Push Registry</strong> to check which <strong>Zuul Push Service</strong> host is connected to the client</li>
<li>delivers the message to the <strong>Zuul Push Service</strong> host</li>
</ol>
</li>
<li><strong>Zuul Push Service</strong> host send the message to the <strong>Client</strong></li>
</ol>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Netflix use a recommendation engine to generate suggested videos for each user. i.e. the home page of the Netflix website for each user is different.</p>
<p><strong>Push vs Pull</strong></p>
<ul>
<li>Pull
<ul>
<li>If too frequent - Overload the system</li>
<li>If too infrequent - Data not fresh enough</li>
</ul>
</li>
<li>Push
<ul>
<li>Most suited for Netflix</li>
</ul>
</li>
</ul>
<p><strong>Push</strong></p>
<p>Define Push:</p>
<ul>
<li><strong>P</strong>ersist</li>
<li><strong>U</strong>ntil</li>
<li><strong>S</strong>omething</li>
<li><strong>H</strong>appens</li>
</ul>
<h3 id="zuul-push-servers"><a class="header" href="#zuul-push-servers">Zuul push servers</a></h3>
<p>Handling millions of persistent connections</p>
<p>Using Non-blocking async-io</p>
<p>C10K challengingL</p>
<ul>
<li>Supporting 10K concurrent connection on a single server</li>
</ul>
<p><strong>Traditional method:</strong></p>
<ul>
<li>1 Connection per Socket</li>
<li>1 Socket per thread</li>
</ul>
<p>Socket --&gt; Read --&gt; Write --&gt; Thread 1
Socket --&gt; Write --&gt; Read --&gt; Thread 2</p>
<p><strong>Async I/O</strong></p>
<p>Socket --&gt; write callback --&gt; single thread --&gt; read callback --&gt; Socket</p>
<p>Netflix use <strong>Netty</strong> for the Async I/O</p>
<h3 id="push-registry"><a class="header" href="#push-registry">Push Registry</a></h3>
<p>Push registry feature checklist (the database used as the push registry should have the following feature):</p>
<ul>
<li>Low read latency</li>
<li>Record expiry (e.g. TTL)</li>
<li>Sharding</li>
<li>Replication</li>
</ul>
<p>TTL -&gt; If the client failed to terminated the connection proactively; the system need to use TTL to remove the registered entry from the Push registry.</p>
<p>Good choice for Push Registry</p>
<ul>
<li>Redis</li>
<li>Cassandra</li>
<li>AWS DynamoDB</li>
</ul>
<p>Netflix use <strong>Dynomite</strong></p>
<p>Dynomite =
+ Redis
+ Auto-sharding
+ Read/Write quorum
+ Cross-region replication</p>
<h3 id="message-processing"><a class="header" href="#message-processing">Message Processing</a></h3>
<p>Message queuing + route delivery</p>
<p>Netflix use <strong>Kafka</strong></p>
<p>Message sender use &quot;FIRE and FORGET&quot; approach:</p>
<ul>
<li>Drop the push message into the queue</li>
<li>Carry on with other tasks</li>
</ul>
<p>Cross-Region Replication</p>
<ul>
<li>Netflix use 3 AWS region</li>
<li>Use AWS Kafka queue replication</li>
</ul>
<p>Queue:</p>
<ul>
<li>Hard to use single queue</li>
<li>Different queues for different priorities</li>
</ul>
<p>Message processor</p>
<ul>
<li>multiple message process in parallel</li>
<li>auto scale based on the number of message in the queue</li>
</ul>
<h3 id="operating-zuul-push"><a class="header" href="#operating-zuul-push">Operating Zuul Push</a></h3>
<p>Different from the Stateless services</p>
<p>Stateful:</p>
<ul>
<li>Persistent connections - long lived statble connection
<ul>
<li>Great for client efficiency</li>
<li>Terrible for quick deploy/rollback</li>
</ul>
</li>
</ul>
<p>Deploy/Rollback</p>
<ul>
<li>Client are not automatically migrate to the newly deployed servers</li>
<li><strong>Thundering herd</strong>: If keep the connection at once, the client would try to connect to the new servers at once (overwhelm the servers)</li>
</ul>
<p>Solution:</p>
<ul>
<li>tear down connection periodically (from the server side)</li>
<li>randomize each connection's lifetime (jitter)</li>
<li>result: randomizing connection lifetime on reconnect peak</li>
<li>Extra: server ask client to close its connection (the party terminate the TCP connection might have a FD on linux remain open for up to 2 mins)</li>
</ul>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<h4 id="how-to-optimize-push-server-most-connection-are-idle"><a class="header" href="#how-to-optimize-push-server-most-connection-are-idle">How to optimize push server? (most connection are idle)?</a></h4>
<p>first approach: big ec2</p>
<ul>
<li>big EC2, as many connection on the single server as possible</li>
<li>Issue: if a server is down: <strong>Thundering herd</strong> happends</li>
</ul>
<p>second approach: goldilocks strategy (just right)</p>
<ul>
<li>m4.large (2v CPU)</li>
<li>84,000 concurrent connection per ec2</li>
</ul>
<p>Optimize for cost, NOT for instance count</p>
<h4 id="how-to-auto-scale-"><a class="header" href="#how-to-auto-scale-">How to auto-scale ?</a></h4>
<p>RPS (request per second) ? NO</p>
<ul>
<li>No RPS for push servers</li>
</ul>
<p>CPU ? NO</p>
<ul>
<li>Instances is not limited by CPU</li>
</ul>
<p>Open Connection ? YES</p>
<ul>
<li>Only factor that is important to a push server</li>
</ul>
<h4 id="aws-elastic-load-balancer-cannot-proxy-websocket"><a class="header" href="#aws-elastic-load-balancer-cannot-proxy-websocket">AWS Elastic Load Balancer cannot proxy WebSocket</a></h4>
<p>ELB does not understand websocket  Upgrade request (A special HTTP request)</p>
<p>Solution: Run ELB as a TCP load balancer (NLB) (Layer 4)</p>
<p>AWS ALB not support WebSocket</p>
<h2 id="use-case-for-push-system"><a class="header" href="#use-case-for-push-system">Use case for Push System</a></h2>
<ul>
<li>On-demand diagnostics
<ul>
<li>Send special diagnostics to devises</li>
</ul>
</li>
<li>Remote recovery</li>
<li>User messaging</li>
</ul>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li>Susheel Aroskar- <a href="https://www.youtube.com/watch?v=6w6E_B55p0E"><em>Scaling Push Messaging for Millions of Devices @Netflix</em></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blog"><a class="header" href="#blog">BLOG</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2022-new-years-resolution"><a class="header" href="#2022-new-years-resolution">2022 New Year's Resolution</a></h1>
<p>Author: Ai, Zi-Xun
Date: 2022-01-04</p>
<h2 id="career-objectives"><a class="header" href="#career-objectives">Career Objectives</a></h2>
<ol>
<li>Start writing blogs and interact with the open source community
<ol>
<li>Serverless in 2022</li>
<li>Open source in 2022</li>
</ol>
</li>
<li>Start contribute to an open source project
<ol>
<li>Pick a Rust open source project</li>
<li>Become a committer of the project</li>
</ol>
</li>
<li>Re-write my personal website in Vue</li>
<li>Produce Rust programming tutorial in Chinese</li>
</ol>
<h2 id="personal-life"><a class="header" href="#personal-life">Personal Life</a></h2>
<ol>
<li>Lose weight (target: 75kg)</li>
<li>Visit a country that I have never been to</li>
<li>Visit Xinjiang or Tibet in China</li>
</ol>
<h2 id="technologies-im-learning-in-2022"><a class="header" href="#technologies-im-learning-in-2022">Technologies I'm learning in 2022</a></h2>
<ol>
<li>Rust</li>
<li>Vue</li>
<li>Quantum Computing on AWS</li>
<li>Serverless
<ol>
<li>AWS
<ol>
<li>Lambda</li>
<li>Step Function</li>
</ol>
</li>
<li>GCP
<ol>
<li>App run</li>
<li>Function</li>
</ol>
</li>
<li>Azure</li>
<li>Alibaba Cloud</li>
</ol>
</li>
</ol>
<h2 id="course-and-books-im-planning-to-complete"><a class="header" href="#course-and-books-im-planning-to-complete">Course and Books I'm planning to complete</a></h2>
<ol>
<li>MIT 6.824</li>
<li>DDIA</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="互联网时代的终结"><a class="header" href="#互联网时代的终结">互联网时代的终结</a></h1>
<p>Author: Ai, Zi-Xun
Date: 2022-01-09</p>
<p>作为自己的第一篇有关互联网的感想文，上来就对这定义了至今数十年的人类文明的互联网时代高谈阔论，似乎有些过于傲慢自大了。但，近来数日愈发的感觉现在的互联网已经不再是十年、二十年前那个自由开放的时代了。那个曾经改变过世界的，由技术革新带来的科技西部时代已经一去不复返了。</p>
<p>两件事情促使了我萌发了写本文的意愿</p>
<ul>
<li>Faker JS 的作者删除了维护已久的代码库</li>
<li>百度搜索椰子水中果糖和葡萄糖比例时得到迎面扑来的垃圾信息</li>
</ul>
<p>虽然两件事情看似毫无关系，但是前者见证了英语互联网大厂贪婪的在开源社区的肩膀上盈利颇丰，而开源作者却一贫如洗；后者则见证了中文互联网从互联互通，变成了各大企业圈地自封，互不相同的可悲现状。</p>
<h2 id="faker-js-的作者删除了维护已久的代码库"><a class="header" href="#faker-js-的作者删除了维护已久的代码库">Faker JS 的作者删除了维护已久的代码库</a></h2>
<h2 id="百度搜索椰子水中果糖和葡萄糖比例时得到迎面扑来的垃圾信息"><a class="header" href="#百度搜索椰子水中果糖和葡萄糖比例时得到迎面扑来的垃圾信息">百度搜索椰子水中果糖和葡萄糖比例时得到迎面扑来的垃圾信息</a></h2>
<p>说来这个故事的因由其实与互联网毫无关系，2022年新年伊始，在三里屯的健身房里我一如即往的举着杠铃，悄悄地欣赏一下身边小哥哥小姐姐精炼的肌肉，耳机里随意的播放着在 Youtube 上看到的一出在 UCSF 举办的有关果糖与肥胖的演讲。</p>
<p>演讲的大意就是，果糖与葡萄糖虽然同为最常见的单糖，同时又以一比一的比例组成了生活中更常见的蔗糖，但是我们的身体对这两种糖类的消化利用模式有着天大的区别。演讲的内容相当的触人深思，不过因与本文无关就暂时一笔带过了。。。</p>
<p>而心里无时不刻想要减肥，又刚刚听完 XXX 的演讲，变自发的好奇起来下午公司给我们提供多的所谓“福利”的“下午茶”中的椰汁到底拥有者什么样的果糖/葡萄糖比例。解锁手机，打开 Chrome 浏览器，输入 baidu.com 后直接查询起了“椰子水 果糖 蔗糖 比例”。然而，这搜索的结果中大量的信息要么就是有关椰子水多么有益健康的软文，要么就是稍稍游泳的椰子水的糖分整体的比例。求而不得，只能转战 Google 用英文来查。搜索 “Coconut water frutous glocous ratio”，前三条结果中就给出了我想要的信息。</p>
<p>此时此刻，内心深处突然担心起中文互联网会不会在德语、意大利语、瑞典语互联网之后沦落为英文互联网的附庸。毋庸置疑，在 Google, Amazon, Twitter 等美国互联网企业占据了全球互联网的生态位后，只有中文互联网有着阿里巴巴、腾讯、字节跳动、百度这样能与之抗衡的力量了。</p>
<p>但是回国三四个月的我发现，现在 2022 年伊始的中文互联网，已经不再是十年前我熟悉的那个生机勃勃的社区了。与之说互联网时互联互通的，不如说现在的互联网时美宜佳大公司内部互联互通的。想要查询诸如上海本地二十四小时核酸哪里可以做的时候，比起打开万能的百度搜索引擎，打开支付宝和微信搜索核酸检测反而更能获得我想要的信息。看着抖音上的短视频，想要分享给朋友，比起直接发送到微信上分享，还不如让大家再抖音上为了分享重新加一次好友来的方便，而这抖音好友之间除了分享看到的短视频，绝不会用它来进行日常交流。</p>
<p>更不不要提十年前大家熟悉的通过网址 URL 分享资源的方式了，微信的审查机制，甚至让微信日常屏蔽掉竞争对手的链接。若不是在 2021 年年末，工信部大规模介入，令互联网企业打破之间的壁垒，我想这一堵越来越高的墙壁将会有一日变得坚不可破，而这墙壁的重量则会成为压死中文互联网互联互通的最后一根稻草。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="把复杂留给自己-把简单留给客户"><a class="header" href="#把复杂留给自己-把简单留给客户">把复杂留给自己 把简单留给客户</a></h1>
<p>Serverless 服务的实践</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverless-新的云服务边疆"><a class="header" href="#serverless-新的云服务边疆">Serverless 新的云服务边疆</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
